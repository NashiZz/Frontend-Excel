/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/binary";
exports.ids = ["vendor-chunks/binary"];
exports.modules = {

/***/ "(ssr)/./node_modules/binary/index.js":
/*!**************************************!*\
  !*** ./node_modules/binary/index.js ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Chainsaw = __webpack_require__(/*! chainsaw */ \"(ssr)/./node_modules/chainsaw/index.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar Buffers = __webpack_require__(/*! buffers */ \"(ssr)/./node_modules/buffers/index.js\");\nvar Vars = __webpack_require__(/*! ./lib/vars.js */ \"(ssr)/./node_modules/binary/lib/vars.js\");\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\n\nexports = module.exports = function (bufOrEm, eventName) {\n    if (Buffer.isBuffer(bufOrEm)) {\n        return exports.parse(bufOrEm);\n    }\n    \n    var s = exports.stream();\n    if (bufOrEm && bufOrEm.pipe) {\n        bufOrEm.pipe(s);\n    }\n    else if (bufOrEm) {\n        bufOrEm.on(eventName || 'data', function (buf) {\n            s.write(buf);\n        });\n        \n        bufOrEm.on('end', function () {\n            s.end();\n        });\n    }\n    return s;\n};\n\nexports.stream = function (input) {\n    if (input) return exports.apply(null, arguments);\n    \n    var pending = null;\n    function getBytes (bytes, cb, skip) {\n        pending = {\n            bytes : bytes,\n            skip : skip,\n            cb : function (buf) {\n                pending = null;\n                cb(buf);\n            },\n        };\n        dispatch();\n    }\n    \n    var offset = null;\n    function dispatch () {\n        if (!pending) {\n            if (caughtEnd) done = true;\n            return;\n        }\n        if (typeof pending === 'function') {\n            pending();\n        }\n        else {\n            var bytes = offset + pending.bytes;\n            \n            if (buffers.length >= bytes) {\n                var buf;\n                if (offset == null) {\n                    buf = buffers.splice(0, bytes);\n                    if (!pending.skip) {\n                        buf = buf.slice();\n                    }\n                }\n                else {\n                    if (!pending.skip) {\n                        buf = buffers.slice(offset, bytes);\n                    }\n                    offset = bytes;\n                }\n                \n                if (pending.skip) {\n                    pending.cb();\n                }\n                else {\n                    pending.cb(buf);\n                }\n            }\n        }\n    }\n    \n    function builder (saw) {\n        function next () { if (!done) saw.next() }\n        \n        var self = words(function (bytes, cb) {\n            return function (name) {\n                getBytes(bytes, function (buf) {\n                    vars.set(name, cb(buf));\n                    next();\n                });\n            };\n        });\n        \n        self.tap = function (cb) {\n            saw.nest(cb, vars.store);\n        };\n        \n        self.into = function (key, cb) {\n            if (!vars.get(key)) vars.set(key, {});\n            var parent = vars;\n            vars = Vars(parent.get(key));\n            \n            saw.nest(function () {\n                cb.apply(this, arguments);\n                this.tap(function () {\n                    vars = parent;\n                });\n            }, vars.store);\n        };\n        \n        self.flush = function () {\n            vars.store = {};\n            next();\n        };\n        \n        self.loop = function (cb) {\n            var end = false;\n            \n            saw.nest(false, function loop () {\n                this.vars = vars.store;\n                cb.call(this, function () {\n                    end = true;\n                    next();\n                }, vars.store);\n                this.tap(function () {\n                    if (end) saw.next()\n                    else loop.call(this)\n                }.bind(this));\n            }, vars.store);\n        };\n        \n        self.buffer = function (name, bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function (buf) {\n                vars.set(name, buf);\n                next();\n            });\n        };\n        \n        self.skip = function (bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function () {\n                next();\n            });\n        };\n        \n        self.scan = function find (name, search) {\n            if (typeof search === 'string') {\n                search = new Buffer(search);\n            }\n            else if (!Buffer.isBuffer(search)) {\n                throw new Error('search must be a Buffer or a string');\n            }\n            \n            var taken = 0;\n            pending = function () {\n                var pos = buffers.indexOf(search, offset + taken);\n                var i = pos-offset-taken;\n                if (pos !== -1) {\n                    pending = null;\n                    if (offset != null) {\n                        vars.set(\n                            name,\n                            buffers.slice(offset, offset + taken + i)\n                        );\n                        offset += taken + i + search.length;\n                    }\n                    else {\n                        vars.set(\n                            name,\n                            buffers.slice(0, taken + i)\n                        );\n                        buffers.splice(0, taken + i + search.length);\n                    }\n                    next();\n                    dispatch();\n                } else {\n                    i = Math.max(buffers.length - search.length - offset - taken, 0);\n\t\t\t\t}\n                taken += i;\n            };\n            dispatch();\n        };\n        \n        self.peek = function (cb) {\n            offset = 0;\n            saw.nest(function () {\n                cb.call(this, vars.store);\n                this.tap(function () {\n                    offset = null;\n                });\n            });\n        };\n        \n        return self;\n    };\n    \n    var stream = Chainsaw.light(builder);\n    stream.writable = true;\n    \n    var buffers = Buffers();\n    \n    stream.write = function (buf) {\n        buffers.push(buf);\n        dispatch();\n    };\n    \n    var vars = Vars();\n    \n    var done = false, caughtEnd = false;\n    stream.end = function () {\n        caughtEnd = true;\n    };\n    \n    stream.pipe = Stream.prototype.pipe;\n    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n        stream[name] = EventEmitter.prototype[name];\n    });\n    \n    return stream;\n};\n\nexports.parse = function parse (buffer) {\n    var self = words(function (bytes, cb) {\n        return function (name) {\n            if (offset + bytes <= buffer.length) {\n                var buf = buffer.slice(offset, offset + bytes);\n                offset += bytes;\n                vars.set(name, cb(buf));\n            }\n            else {\n                vars.set(name, null);\n            }\n            return self;\n        };\n    });\n    \n    var offset = 0;\n    var vars = Vars();\n    self.vars = vars.store;\n    \n    self.tap = function (cb) {\n        cb.call(self, vars.store);\n        return self;\n    };\n    \n    self.into = function (key, cb) {\n        if (!vars.get(key)) {\n            vars.set(key, {});\n        }\n        var parent = vars;\n        vars = Vars(parent.get(key));\n        cb.call(self, vars.store);\n        vars = parent;\n        return self;\n    };\n    \n    self.loop = function (cb) {\n        var end = false;\n        var ender = function () { end = true };\n        while (end === false) {\n            cb.call(self, ender, vars.store);\n        }\n        return self;\n    };\n    \n    self.buffer = function (name, size) {\n        if (typeof size === 'string') {\n            size = vars.get(size);\n        }\n        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n        offset += size;\n        vars.set(name, buf);\n        \n        return self;\n    };\n    \n    self.skip = function (bytes) {\n        if (typeof bytes === 'string') {\n            bytes = vars.get(bytes);\n        }\n        offset += bytes;\n        \n        return self;\n    };\n    \n    self.scan = function (name, search) {\n        if (typeof search === 'string') {\n            search = new Buffer(search);\n        }\n        else if (!Buffer.isBuffer(search)) {\n            throw new Error('search must be a Buffer or a string');\n        }\n        vars.set(name, null);\n        \n        // simple but slow string search\n        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n            for (\n                var j = 0;\n                j < search.length && buffer[offset+i+j] === search[j];\n                j++\n            );\n            if (j === search.length) break;\n        }\n        \n        vars.set(name, buffer.slice(offset, offset + i));\n        offset += i + search.length;\n        return self;\n    };\n    \n    self.peek = function (cb) {\n        var was = offset;\n        cb.call(self, vars.store);\n        offset = was;\n        return self;\n    };\n    \n    self.flush = function () {\n        vars.store = {};\n        return self;\n    };\n    \n    self.eof = function () {\n        return offset >= buffer.length;\n    };\n    \n    return self;\n};\n\n// convert byte strings to unsigned little endian numbers\nfunction decodeLEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256,i) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to unsigned big endian numbers\nfunction decodeBEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to signed big endian numbers\nfunction decodeBEs (bytes) {\n    var val = decodeBEu(bytes);\n    if ((bytes[0] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\n// convert byte strings to signed little endian numbers\nfunction decodeLEs (bytes) {\n    var val = decodeLEu(bytes);\n    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\nfunction words (decode) {\n    var self = {};\n    \n    [ 1, 2, 4, 8 ].forEach(function (bytes) {\n        var bits = bytes * 8;\n        \n        self['word' + bits + 'le']\n        = self['word' + bits + 'lu']\n        = decode(bytes, decodeLEu);\n        \n        self['word' + bits + 'ls']\n        = decode(bytes, decodeLEs);\n        \n        self['word' + bits + 'be']\n        = self['word' + bits + 'bu']\n        = decode(bytes, decodeBEu);\n        \n        self['word' + bits + 'bs']\n        = decode(bytes, decodeBEs);\n    });\n    \n    // word8be(n) == word8le(n) for all n\n    self.word8 = self.word8u = self.word8be;\n    self.word8s = self.word8bs;\n    \n    return self;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmluYXJ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyx3REFBVTtBQUNqQyxtQkFBbUIsMERBQThCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxzREFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMsOERBQWU7QUFDbEMsYUFBYSxvREFBd0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmFzb3BjaG9ja3NhbmNoYXJvZW4vRG9jdW1lbnRzL0ludGVybi1Qb29uc2FwL1Byb2plY3RFeGNlbC9mcm9udGVuZC1leGNlbC9ub2RlX21vZHVsZXMvYmluYXJ5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDaGFpbnNhdyA9IHJlcXVpcmUoJ2NoYWluc2F3Jyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIEJ1ZmZlcnMgPSByZXF1aXJlKCdidWZmZXJzJyk7XG52YXIgVmFycyA9IHJlcXVpcmUoJy4vbGliL3ZhcnMuanMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZPckVtLCBldmVudE5hbWUpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1Zk9yRW0pKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhcnNlKGJ1Zk9yRW0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcyA9IGV4cG9ydHMuc3RyZWFtKCk7XG4gICAgaWYgKGJ1Zk9yRW0gJiYgYnVmT3JFbS5waXBlKSB7XG4gICAgICAgIGJ1Zk9yRW0ucGlwZShzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmT3JFbSkge1xuICAgICAgICBidWZPckVtLm9uKGV2ZW50TmFtZSB8fCAnZGF0YScsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgIHMud3JpdGUoYnVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBidWZPckVtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59O1xuXG5leHBvcnRzLnN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCkgcmV0dXJuIGV4cG9ydHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBcbiAgICB2YXIgcGVuZGluZyA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0Qnl0ZXMgKGJ5dGVzLCBjYiwgc2tpcCkge1xuICAgICAgICBwZW5kaW5nID0ge1xuICAgICAgICAgICAgYnl0ZXMgOiBieXRlcyxcbiAgICAgICAgICAgIHNraXAgOiBza2lwLFxuICAgICAgICAgICAgY2IgOiBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2IoYnVmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGRpc3BhdGNoKCk7XG4gICAgfVxuICAgIFxuICAgIHZhciBvZmZzZXQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoICgpIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2F1Z2h0RW5kKSBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBieXRlcyA9IG9mZnNldCArIHBlbmRpbmcuYnl0ZXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+PSBieXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1ZmZlcnMuc3BsaWNlKDAsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nLnNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmcuc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmZmVycy5zbGljZShvZmZzZXQsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBieXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLmNiKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLmNiKGJ1Zik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGJ1aWxkZXIgKHNhdykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0ICgpIHsgaWYgKCFkb25lKSBzYXcubmV4dCgpIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gd29yZHMoZnVuY3Rpb24gKGJ5dGVzLCBjYikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZ2V0Qnl0ZXMoYnl0ZXMsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQobmFtZSwgY2IoYnVmKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2VsZi50YXAgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNhdy5uZXN0KGNiLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYuaW50byA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgICAgICBpZiAoIXZhcnMuZ2V0KGtleSkpIHZhcnMuc2V0KGtleSwge30pO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHZhcnM7XG4gICAgICAgICAgICB2YXJzID0gVmFycyhwYXJlbnQuZ2V0KGtleSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzYXcubmVzdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcnMgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXJzLnN0b3JlID0ge307XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLmxvb3AgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2F3Lm5lc3QoZmFsc2UsIGZ1bmN0aW9uIGxvb3AgKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFycyA9IHZhcnMuc3RvcmU7XG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCB2YXJzLnN0b3JlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQpIHNhdy5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBsb29wLmNhbGwodGhpcylcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSwgdmFycy5zdG9yZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLmJ1ZmZlciA9IGZ1bmN0aW9uIChuYW1lLCBieXRlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHZhcnMuZ2V0KGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Qnl0ZXMoYnl0ZXMsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBidWYpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgc2VsZi5za2lwID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gdmFycy5nZXQoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBnZXRCeXRlcyhieXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgc2VsZi5zY2FuID0gZnVuY3Rpb24gZmluZCAobmFtZSwgc2VhcmNoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBuZXcgQnVmZmVyKHNlYXJjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlYXJjaCBtdXN0IGJlIGEgQnVmZmVyIG9yIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0YWtlbiA9IDA7XG4gICAgICAgICAgICBwZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBidWZmZXJzLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQgKyB0YWtlbik7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBwb3Mtb2Zmc2V0LXRha2VuO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIHRha2VuICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGFrZW4gKyBpICsgc2VhcmNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zbGljZSgwLCB0YWtlbiArIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zcGxpY2UoMCwgdGFrZW4gKyBpICsgc2VhcmNoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBNYXRoLm1heChidWZmZXJzLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGggLSBvZmZzZXQgLSB0YWtlbiwgMCk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICB0YWtlbiArPSBpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLnBlZWsgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBzYXcubmVzdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHN0cmVhbSA9IENoYWluc2F3LmxpZ2h0KGJ1aWxkZXIpO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IHRydWU7XG4gICAgXG4gICAgdmFyIGJ1ZmZlcnMgPSBCdWZmZXJzKCk7XG4gICAgXG4gICAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICBidWZmZXJzLnB1c2goYnVmKTtcbiAgICAgICAgZGlzcGF0Y2goKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB2YXJzID0gVmFycygpO1xuICAgIFxuICAgIHZhciBkb25lID0gZmFsc2UsIGNhdWdodEVuZCA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhdWdodEVuZCA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudEVtaXR0ZXIucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHN0cmVhbVtuYW1lXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbbmFtZV07XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHN0cmVhbTtcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoYnVmZmVyKSB7XG4gICAgdmFyIHNlbGYgPSB3b3JkcyhmdW5jdGlvbiAoYnl0ZXMsIGNiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCArIGJ5dGVzIDw9IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBieXRlcztcbiAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBjYihidWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhcnMuc2V0KG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHZhcnMgPSBWYXJzKCk7XG4gICAgc2VsZi52YXJzID0gdmFycy5zdG9yZTtcbiAgICBcbiAgICBzZWxmLnRhcCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhcnMuc3RvcmUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuaW50byA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgIGlmICghdmFycy5nZXQoa2V5KSkge1xuICAgICAgICAgICAgdmFycy5zZXQoa2V5LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHZhcnM7XG4gICAgICAgIHZhcnMgPSBWYXJzKHBhcmVudC5nZXQoa2V5KSk7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFycy5zdG9yZSk7XG4gICAgICAgIHZhcnMgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5sb29wID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuZGVyID0gZnVuY3Rpb24gKCkgeyBlbmQgPSB0cnVlIH07XG4gICAgICAgIHdoaWxlIChlbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHNlbGYsIGVuZGVyLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuYnVmZmVyID0gZnVuY3Rpb24gKG5hbWUsIHNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2l6ZSA9IHZhcnMuZ2V0KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBvZmZzZXQgKyBzaXplKSk7XG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXJzLnNldChuYW1lLCBidWYpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLnNraXAgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gdmFycy5nZXQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBieXRlcztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5zY2FuID0gZnVuY3Rpb24gKG5hbWUsIHNlYXJjaCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IG5ldyBCdWZmZXIoc2VhcmNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VhcmNoIG11c3QgYmUgYSBCdWZmZXIgb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJzLnNldChuYW1lLCBudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHNpbXBsZSBidXQgc2xvdyBzdHJpbmcgc2VhcmNoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDw9IGJ1ZmZlci5sZW5ndGggLSBzZWFyY2gubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICBqIDwgc2VhcmNoLmxlbmd0aCAmJiBidWZmZXJbb2Zmc2V0K2kral0gPT09IHNlYXJjaFtqXTtcbiAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaiA9PT0gc2VhcmNoLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhcnMuc2V0KG5hbWUsIGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGkpKTtcbiAgICAgICAgb2Zmc2V0ICs9IGkgKyBzZWFyY2gubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYucGVlayA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgd2FzID0gb2Zmc2V0O1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhcnMuc3RvcmUpO1xuICAgICAgICBvZmZzZXQgPSB3YXM7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFycy5zdG9yZSA9IHt9O1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuZW9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGg7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGNvbnZlcnQgYnl0ZSBzdHJpbmdzIHRvIHVuc2lnbmVkIGxpdHRsZSBlbmRpYW4gbnVtYmVyc1xuZnVuY3Rpb24gZGVjb2RlTEV1IChieXRlcykge1xuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjICs9IE1hdGgucG93KDI1NixpKSAqIGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG4vLyBjb252ZXJ0IGJ5dGUgc3RyaW5ncyB0byB1bnNpZ25lZCBiaWcgZW5kaWFuIG51bWJlcnNcbmZ1bmN0aW9uIGRlY29kZUJFdSAoYnl0ZXMpIHtcbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjYyArPSBNYXRoLnBvdygyNTYsIGJ5dGVzLmxlbmd0aCAtIGkgLSAxKSAqIGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG4vLyBjb252ZXJ0IGJ5dGUgc3RyaW5ncyB0byBzaWduZWQgYmlnIGVuZGlhbiBudW1iZXJzXG5mdW5jdGlvbiBkZWNvZGVCRXMgKGJ5dGVzKSB7XG4gICAgdmFyIHZhbCA9IGRlY29kZUJFdShieXRlcyk7XG4gICAgaWYgKChieXRlc1swXSAmIDB4ODApID09IDB4ODApIHtcbiAgICAgICAgdmFsIC09IE1hdGgucG93KDI1NiwgYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gY29udmVydCBieXRlIHN0cmluZ3MgdG8gc2lnbmVkIGxpdHRsZSBlbmRpYW4gbnVtYmVyc1xuZnVuY3Rpb24gZGVjb2RlTEVzIChieXRlcykge1xuICAgIHZhciB2YWwgPSBkZWNvZGVMRXUoYnl0ZXMpO1xuICAgIGlmICgoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJiAweDgwKSA9PSAweDgwKSB7XG4gICAgICAgIHZhbCAtPSBNYXRoLnBvdygyNTYsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHdvcmRzIChkZWNvZGUpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuICAgIFxuICAgIFsgMSwgMiwgNCwgOCBdLmZvckVhY2goZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciBiaXRzID0gYnl0ZXMgKiA4O1xuICAgICAgICBcbiAgICAgICAgc2VsZlsnd29yZCcgKyBiaXRzICsgJ2xlJ11cbiAgICAgICAgPSBzZWxmWyd3b3JkJyArIGJpdHMgKyAnbHUnXVxuICAgICAgICA9IGRlY29kZShieXRlcywgZGVjb2RlTEV1KTtcbiAgICAgICAgXG4gICAgICAgIHNlbGZbJ3dvcmQnICsgYml0cyArICdscyddXG4gICAgICAgID0gZGVjb2RlKGJ5dGVzLCBkZWNvZGVMRXMpO1xuICAgICAgICBcbiAgICAgICAgc2VsZlsnd29yZCcgKyBiaXRzICsgJ2JlJ11cbiAgICAgICAgPSBzZWxmWyd3b3JkJyArIGJpdHMgKyAnYnUnXVxuICAgICAgICA9IGRlY29kZShieXRlcywgZGVjb2RlQkV1KTtcbiAgICAgICAgXG4gICAgICAgIHNlbGZbJ3dvcmQnICsgYml0cyArICdicyddXG4gICAgICAgID0gZGVjb2RlKGJ5dGVzLCBkZWNvZGVCRXMpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIHdvcmQ4YmUobikgPT0gd29yZDhsZShuKSBmb3IgYWxsIG5cbiAgICBzZWxmLndvcmQ4ID0gc2VsZi53b3JkOHUgPSBzZWxmLndvcmQ4YmU7XG4gICAgc2VsZi53b3JkOHMgPSBzZWxmLndvcmQ4YnM7XG4gICAgXG4gICAgcmV0dXJuIHNlbGY7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/binary/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/binary/lib/vars.js":
/*!*****************************************!*\
  !*** ./node_modules/binary/lib/vars.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = function (store) {\n    function getset (name, value) {\n        var node = vars.store;\n        var keys = name.split('.');\n        keys.slice(0,-1).forEach(function (k) {\n            if (node[k] === undefined) node[k] = {};\n            node = node[k]\n        });\n        var key = keys[keys.length - 1];\n        if (arguments.length == 1) {\n            return node[key];\n        }\n        else {\n            return node[key] = value;\n        }\n    }\n    \n    var vars = {\n        get : function (name) {\n            return getset(name);\n        },\n        set : function (name, value) {\n            return getset(name, value);\n        },\n        store : store || {},\n    };\n    return vars;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmluYXJ5L2xpYi92YXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmFzb3BjaG9ja3NhbmNoYXJvZW4vRG9jdW1lbnRzL0ludGVybi1Qb29uc2FwL1Byb2plY3RFeGNlbC9mcm9udGVuZC1leGNlbC9ub2RlX21vZHVsZXMvYmluYXJ5L2xpYi92YXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgZnVuY3Rpb24gZ2V0c2V0IChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHZhcnMuc3RvcmU7XG4gICAgICAgIHZhciBrZXlzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICBrZXlzLnNsaWNlKDAsLTEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChub2RlW2tdID09PSB1bmRlZmluZWQpIG5vZGVba10gPSB7fTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlW2tdXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciB2YXJzID0ge1xuICAgICAgICBnZXQgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldHNldChuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0c2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcmUgOiBzdG9yZSB8fCB7fSxcbiAgICB9O1xuICAgIHJldHVybiB2YXJzO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/binary/lib/vars.js\n");

/***/ })

};
;